#!/usr/bin/env node

/**
 * Test for issue #309 fix: Make sure we focus on only important facts in the main prompt
 * and correctly filter out comments generated by our tool
 */

import { strict as assert } from 'assert';

console.log('Testing issue #309 fix...\n');

// Simulate comment filtering logic
const testCommentFiltering = () => {
  console.log('Test 1: Comment filtering with log patterns');

  const logPatterns = [
    /üìä.*Log file|solution\s+draft.*log/i,
    /üîó.*Link:|üíª.*Session:/i,
    /Generated with.*solve\.mjs/i,
    /Session ID:|Log file available:/i
  ];

  const mockComments = [
    {
      body: 'This is a real user comment asking for changes',
      user: { login: 'other-user' },
      created_at: '2025-09-27T12:00:00Z'
    },
    {
      body: 'üìä Log file available at: https://example.com\n\nGenerated with solve.mjs',
      user: { login: 'current-user' },
      created_at: '2025-09-27T11:00:00Z'
    },
    {
      body: 'üíª Session: abc123\nüîó Link: https://example.com',
      user: { login: 'current-user' },
      created_at: '2025-09-27T11:30:00Z'
    },
    {
      body: 'Another real comment from a reviewer',
      user: { login: 'reviewer' },
      created_at: '2025-09-27T13:00:00Z'
    }
  ];

  const lastCommitTime = new Date('2025-09-27T10:00:00Z');
  const workStartTime = new Date('2025-09-27T11:00:00Z');
  const currentUser = 'current-user';

  // Filter comments using the same logic as the fixed code
  const filteredComments = mockComments.filter(comment => {
    const commentTime = new Date(comment.created_at);
    const isAfterCommit = commentTime > lastCommitTime;
    const isNotLogPattern = !logPatterns.some(pattern => pattern.test(comment.body || ''));

    // Filter out comments from current user if made after work started
    if (workStartTime && currentUser && comment.user && comment.user.login === currentUser) {
      const isAfterWorkStart = commentTime > new Date(workStartTime);
      return isAfterCommit && !isAfterWorkStart && isNotLogPattern;
    }

    return isAfterCommit && isNotLogPattern;
  });

  console.log(`Total comments: ${mockComments.length}`);
  console.log(`Comments after last commit: ${mockComments.filter(c => new Date(c.created_at) > lastCommitTime).length}`);
  console.log(`Filtered comments (excluding logs and own after work start): ${filteredComments.length}`);
  console.log('');

  // Should only count 2 real user comments (not the 2 log comments from current user)
  assert.equal(filteredComments.length, 2, 'Should filter out log comments and own comments after work start');
  assert.equal(filteredComments[0].body, 'This is a real user comment asking for changes');
  assert.equal(filteredComments[1].body, 'Another real comment from a reviewer');

  console.log('‚úÖ Test 1 passed: Log comments are correctly filtered out\n');
};

const testFeedbackLinesOutput = () => {
  console.log('Test 2: Feedback lines output format');

  const feedbackLines = [];
  const newPrComments = 1; // Already filtered count
  const newIssueComments = 0;

  // Simulate the fixed code's logic (lines 199-204)
  if (newPrComments > 0) {
    feedbackLines.push(`New comments on the pull request: ${newPrComments}`);
  }
  if (newIssueComments > 0) {
    feedbackLines.push(`New comments on the issue: ${newIssueComments}`);
  }

  console.log('Output:');
  feedbackLines.forEach(line => console.log(`  ${line}`));
  console.log('');

  // Should only have one line with the filtered count
  assert.equal(feedbackLines.length, 1, 'Should only have one feedback line');
  assert.equal(feedbackLines[0], 'New comments on the pull request: 1', 'Should show filtered count');
  assert.ok(!feedbackLines.some(line => line.includes('New non-log comments')), 'Should NOT have separate non-log comments line');

  console.log('‚úÖ Test 2 passed: Feedback lines only show filtered counts\n');
};

const testNoCommentsScenario = () => {
  console.log('Test 3: No comments scenario (should not output anything)');

  const feedbackLines = [];
  const newPrComments = 0;
  const newIssueComments = 0;

  if (newPrComments > 0) {
    feedbackLines.push(`New comments on the pull request: ${newPrComments}`);
  }
  if (newIssueComments > 0) {
    feedbackLines.push(`New comments on the issue: ${newIssueComments}`);
  }

  console.log(`Output: ${feedbackLines.length === 0 ? '(empty - no tokens wasted)' : feedbackLines.join('\\n')}`);
  console.log('');

  assert.equal(feedbackLines.length, 0, 'Should not output anything when no comments');

  console.log('‚úÖ Test 3 passed: No output when no comments (saves tokens)\n');
};

// Run all tests
try {
  testCommentFiltering();
  testFeedbackLinesOutput();
  testNoCommentsScenario();

  console.log('========================================');
  console.log('‚úÖ All tests passed!');
  console.log('========================================');
  console.log('\nIssue #309 fix verified:');
  console.log('- Comments are properly filtered from the beginning');
  console.log('- Only filtered counts are shown');
  console.log('- No confusing "New non-log comments: X (Y total)" message');
  console.log('- Log comments and own comments during work session are excluded');
} catch (error) {
  console.error('\n‚ùå Test failed:', error.message);
  console.error(error.stack);
  process.exit(1);
}